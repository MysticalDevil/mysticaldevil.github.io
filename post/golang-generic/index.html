<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go 新特性 -- 泛型 - MysticalDevil&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="MysticalDevil" /><meta name="description" content="序言 2022年3月15日，争议非常大但同时也备受期待的泛型终于伴随着 Go 1.18 发布了。设计者之前还说为了 Go 语言的简洁，不会加入泛型🙄 为什么要引入泛" /><meta name="keywords" content="Hugo, theme, even, blog, mystical, devil, mysticaldevil, programming" />






<meta name="generator" content="Hugo 0.109.0 with theme even" />


<link rel="canonical" href="/post/golang-generic/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go 新特性 -- 泛型" />
<meta property="og:description" content="序言 2022年3月15日，争议非常大但同时也备受期待的泛型终于伴随着 Go 1.18 发布了。设计者之前还说为了 Go 语言的简洁，不会加入泛型🙄 为什么要引入泛" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/golang-generic/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-01-23T19:50:59+08:00" />
<meta property="article:modified_time" content="2023-01-23T19:50:59+08:00" />
<meta itemprop="name" content="Go 新特性 -- 泛型">
<meta itemprop="description" content="序言 2022年3月15日，争议非常大但同时也备受期待的泛型终于伴随着 Go 1.18 发布了。设计者之前还说为了 Go 语言的简洁，不会加入泛型🙄 为什么要引入泛"><meta itemprop="datePublished" content="2023-01-23T19:50:59+08:00" />
<meta itemprop="dateModified" content="2023-01-23T19:50:59+08:00" />
<meta itemprop="wordCount" content="7690">
<meta itemprop="keywords" content="Go,Generic," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 新特性 -- 泛型"/>
<meta name="twitter:description" content="序言 2022年3月15日，争议非常大但同时也备受期待的泛型终于伴随着 Go 1.18 发布了。设计者之前还说为了 Go 语言的简洁，不会加入泛型🙄 为什么要引入泛"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">DEvil</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">DEvil</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go 新特性 -- 泛型</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-01-23 </span>
        <div class="post-category">
            <a href="/categories/go/"> Go </a>
            <a href="/categories/programming/"> Programming </a>
            <a href="/categories/notes/"> “Notes&#34; </a>
            </div>
          <span class="more-meta"> 约 7690 字 </span>
          <span class="more-meta"> 预计阅读 16 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#序言">序言</a></li>
        <li><a href="#为什么要引入泛型">为什么要引入泛型</a></li>
        <li><a href="#go-的泛型">Go 的泛型</a>
          <ul>
            <li><a href="#类型形参类型实参类型约束和泛型类型">类型形参、类型实参、类型约束和泛型类型</a></li>
            <li><a href="#其他的泛型类型">其他的泛型类型</a></li>
            <li><a href="#类型形参的嵌套">类型形参的嵌套</a></li>
            <li><a href="#常见语法错误">常见语法错误</a></li>
            <li><a href="#特殊的泛型类型">特殊的泛型类型</a></li>
            <li><a href="#泛型类型的套娃">泛型类型的套娃</a></li>
            <li><a href="#类型约束的两种写法">类型约束的两种写法</a></li>
          </ul>
        </li>
        <li><a href="#泛型-receiver">泛型 Receiver</a>
          <ul>
            <li><a href="#基于泛型的队列">基于泛型的队列</a></li>
          </ul>
        </li>
        <li><a href="#泛型函数">泛型函数</a>
          <ul>
            <li><a href="#泛型方法">泛型方法？</a></li>
          </ul>
        </li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#变复杂的接口">变复杂的接口</a>
          <ul>
            <li><a href="#指定底层类型-">指定底层类型： ~</a></li>
            <li><a href="#从方法集method-type到类型集type-set">从方法集（Method Type）到类型集（Type Set）</a></li>
            <li><a href="#接口定义的变化">接口定义的变化</a></li>
            <li><a href="#类型的并集">类型的并集</a></li>
            <li><a href="#类型的交集">类型的交集</a></li>
            <li><a href="#空接口和-any">空接口和 <code>any</code></a></li>
            <li><a href="#可比较comparable和可排序ordered">可比较（Comparable）和可排序（Ordered）</a></li>
            <li><a href="#接口的两种类型">接口的两种类型</a></li>
            <li><a href="#泛型接口">泛型接口</a></li>
            <li><a href="#接口定义的种种限制">接口定义的种种限制</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#参考">参考</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="序言">序言</h2>
<p>2022年3月15日，争议非常大但同时也备受期待的泛型终于伴随着 Go 1.18 发布了。<del>设计者之前还说为了 Go 语言的简洁，不会加入泛型🙄</del></p>
<h2 id="为什么要引入泛型">为什么要引入泛型</h2>
<p>在 1.18 版本之前，如果想在 Go 语言中让一个函数/方法支持多种类型，那么开发者只能为每个类型挨个实现相关的函数/方法。比如我有一个 Add 函数，定义如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是上面的函数只支持 int 类型，如果我想支持其他类型那么需要为每个类型都写一个对应函数（比如著名的cast包，用于类型转换），如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">AddFloat32</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">float32</span><span class="p">)</span> <span class="kt">float32</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">AddFloat64</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这也太麻烦了吧，🌿</p>
<p>不过我们也可以使用 空接口 <code>interface{}</code> 加反射的方式实现（现在空接口被包装为 <code>any</code> 关键字），使用如下方式来实现。<del>这不是更麻烦吗</del></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Process</span><span class="p">(</span><span class="nx">x</span> <span class="nx">any</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;x is an int with value&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Int</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;x is a string with value&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Float64</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;x is a float64 with value&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Float</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;x is of unknown type&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是这种实现方法有很多问题：
1. 用起来很麻烦，反正 go 语言的反射我是没怎么写明白
2. 缺少了编译时的类型检查，很容易出错，这对于我们实现的应用来说是很致命的
3. 性能不理想，因为反射是运行时的东西</p>
<p>而在泛型适用的时候，它能解决上面这些问题。但这也不意味着泛型是万金油，泛型有着自己的适用场景，当你疑惑是不是该用泛型的话，请记住下面这条经验：</p>
<blockquote>
<p>如果你经常要分别为不同的类型写完全相同逻辑的代码，那么使用泛型将是最合适的选择</p>
</blockquote>
<h2 id="go-的泛型">Go 的泛型</h2>
<p>Go 语言引入了如下的新概念来实现泛型</p>
<ul>
<li>类型形参（Type parameter）</li>
<li>类型实参（Type argument）</li>
<li>类型形参列表（Type parameter list）</li>
<li>类型约束（Type constraint）</li>
<li>实例化（Instantiations）</li>
<li>泛型类型（Generic type）</li>
<li>泛型接收器（Generic receiver）</li>
<li>泛型函数（Generic function）</li>
</ul>
<p>等等等等. . .这 TM 也太多了吧，下面来一个个介绍一下</p>
<h3 id="类型形参类型实参类型约束和泛型类型">类型形参、类型实参、类型约束和泛型类型</h3>
<p>在 1.18 之前，NewType 一般只允许有一个类型，例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">IntSlice</span> <span class="p">[]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">a</span> <span class="nx">IntSlice</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">a</span> <span class="nx">IntSlice</span> <span class="p">=</span> <span class="p">[]</span><span class="nb">float64</span><span class="p">(</span><span class="mf">1.</span><span class="nx">o</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="c1">// error 因为 IntSlice 底层为 []int
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那我想要一个可以容纳其他类型的切片怎么办？简单，对应的每个类型写一个就行<del>🌿</del></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Float32Slice</span> <span class="p">[]</span><span class="kt">float32</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Float64Slice</span> <span class="p">[]</span><span class="kt">float64</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">StringSlice</span> <span class="p">[]</span><span class="kt">string</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>泛型的引入就很好的解决了这一问题，即</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">float32</span> <span class="p">|</span> <span class="kt">float64</span> <span class="p">|</span> <span class="kt">string</span><span class="p">]</span> <span class="p">[]</span><span class="nx">T</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不同于其他语言的泛型使用尖括号<code>&lt;&gt;</code>，Go语言为了编译器的简单（不是我说的）使用了方括号<code>[]</code> <del>也挺反人类的</del></p>
<p>对于以上个各部分对应的概念如下</p>
<ul>
<li><code>T</code> 为<strong>类型形参</strong>，在定义 Slice 的类型时不代表具体的类型，只作为一个占位符</li>
<li><code>int | float32 | float64 | string</code> 为<strong>类型约束</strong>，中间的<code>|</code>就是告诉编译器我只接受这四种类型的实参</li>
<li>中括号里的<code>[T int | float32 | float64 | string]</code>一整串因为定义了所有的类型形参，所以称其为<strong>类型形参列表</strong></li>
<li>这里定义了一个 NewType 为 Slice[T]</li>
</ul>
<p>这种类型定义中带类型形参的类型，称之为<strong>泛型类型</strong></p>
<p>泛型类型不能直接使用，需要传入<strong>类型实参</strong>，即类型形参列表中的类型，而传入类型的操作被称为<strong>实例化</strong>，例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 这里传入了类型实参 int，泛型类型 Slice[T] 被实例化了具体的类型为 Slice[int]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">a</span> <span class="nx">Slice</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Type Name: %T\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这里被实例化为了 Slice[string]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">s</span> <span class="nx">Slice</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="s">&#34;c&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Type Name: %t\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// error，byte 不在类型约束中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">b</span> <span class="nx">Slice</span><span class="p">[</span><span class="kt">byte</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>类型形参的数量不止有一个  <del>这个泛型map就开始反人类了，这么多<code>[]</code>，有点眼花</del></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// NewMap 定义两个类型形参 K， V
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这个类型的名字就叫做: NewMap[K, V]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">NewMap</span> <span class="p">[</span><span class="nx">K</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">V</span> <span class="kt">float32</span> <span class="p">|</span> <span class="kt">float64</span><span class="p">]</span> <span class="kd">map</span><span class="p">[</span><span class="nx">KEY</span><span class="p">]</span><span class="nx">VALUE</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">m</span> <span class="nx">NewMap</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float64</span><span class="p">]</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">float64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="mi">1</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="mi">2</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="其他的泛型类型">其他的泛型类型</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 泛型结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">NewStruct</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">string</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Data</span> <span class="nx">T</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 泛型接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">IPrintData</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">float64</span> <span class="p">|</span> <span class="kt">string</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Print</span><span class="p">(</span><span class="nx">data</span> <span class="nx">T</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 泛型Channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">NewChan</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">string</span><span class="p">]</span> <span class="kd">chan</span> <span class="nx">T</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="类型形参的嵌套">类型形参的嵌套</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">WowStruct</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">float32</span><span class="p">,</span> <span class="nx">S</span> <span class="p">[]</span><span class="nx">T</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Data</span> <span class="nx">S</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MinValue</span> <span class="nx">T</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MaxValue</span> <span class="nx">T</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s</span> <span class="nx">WowStruct</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">]</span> <span class="p">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Data</span><span class="p">:</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MinValue</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MaxValue</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="常见语法错误">常见语法错误</h3>
<ol>
<li>
<p>定义泛型时，**基础类型不能只有类型形参，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// error, 类型形参不能单独使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">CommonType</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">string</span> <span class="p">|</span> <span class="kt">float64</span><span class="p">]</span> <span class="nx">T</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>当类型约束的一些写法会被编译器误认为时表达式时会报错，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// error, T *int 会被编译器误认为是表达式 T 乘以 int，而不是 int 指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">NewType</span><span class="p">[</span><span class="nx">T</span> <span class="o">*</span><span class="kt">int</span><span class="p">]</span> <span class="p">[]</span><span class="nx">T</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// error, 这里的 * 会被认为是乘法符号，| 会被认为时按位或
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">NewType</span><span class="p">[</span><span class="nx">T</span> <span class="o">*</span><span class="kt">int</span> <span class="p">|</span> <span class="kt">float64</span><span class="p">]</span> <span class="p">[]</span><span class="nx">T</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">NewType</span><span class="p">[</span><span class="nf">T</span> <span class="p">(</span><span class="kt">int</span><span class="p">)]</span> <span class="p">[]</span><span class="nx">T</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如何避免这种错误呢？可以给类型约束用 <code>interface{}</code> 包上 或者加上逗号消除歧义，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NewType</span><span class="p">[</span><span class="nx">T</span> <span class="kd">interface</span><span class="p">{</span><span class="o">*</span><span class="kt">int</span><span class="p">}]</span> <span class="p">[]</span><span class="nx">T</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NewType</span><span class="p">[</span><span class="nx">T</span> <span class="kd">interface</span><span class="p">{</span><span class="o">*</span><span class="kt">int</span><span class="p">|</span><span class="o">*</span><span class="kt">float64</span><span class="p">}]</span> <span class="p">[]</span><span class="nx">T</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 类型约束只有一个类型，可以添加一个逗号消除歧义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">NewType</span><span class="p">[</span><span class="nx">T</span> <span class="o">*</span><span class="kt">int</span><span class="p">,]</span> <span class="p">[]</span><span class="nx">T</span>
</span></span><span class="line"><span class="cl"><span class="c1">// error，类型约束有多个时加逗号无法消除歧义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">NewType</span><span class="p">[</span><span class="nx">T</span> <span class="o">*</span><span class="kt">int</span> <span class="p">|</span> <span class="o">*</span><span class="kt">float64</span><span class="p">,]</span> <span class="p">[]</span><span class="nx">T</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h3 id="特殊的泛型类型">特殊的泛型类型</h3>
<p>这里讨论一下比较特殊的泛型类型，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Foo</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">string</span><span class="p">]</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">a</span> <span class="nx">Foo</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span> <span class="p">=</span> <span class="mi">123</span> <span class="c1">// right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">a</span> <span class="nx">Foo</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span> <span class="p">=</span> <span class="mi">123</span> <span class="c1">// right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">a</span> <span class="nx">Foo</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;bar&#34;</span> <span class="c1">// error，因为&#34;hello&#34;不能赋值给底层类型int
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里虽然使用了类型形参，但是它的底层类型还是 int 类型，无论传入什么类型实参，实例化之后都是 int 类型</p>
<h3 id="泛型类型的套娃">泛型类型的套娃</h3>
<p>泛型类型可以进行套娃，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 先定义一个 Slice[T]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">string</span> <span class="p">|</span> <span class="kt">float32</span> <span class="p">|</span> <span class="kt">float64</span><span class="p">]</span> <span class="p">[]</span><span class="nx">T</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 再定义一个基于 Slice[T] 的泛型类型 FloatSlice[T]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">FloatSlice</span><span class="p">[</span><span class="nx">T</span> <span class="kt">float32</span> <span class="p">|</span> <span class="kt">float64</span><span class="p">]</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// error, 泛型类型 Slice[T] 的类型约束不包含 uint, uint8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">UintSlice</span><span class="p">[</span><span class="nx">T</span> <span class="kt">uint</span> <span class="p">|</span> <span class="kt">uint8</span><span class="p">]</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义一个基于 Slice[T] 的 IntAndStringSlice[T]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">IntAndStringSlice</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">string</span><span class="p">]</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 在 map 中嵌套泛型类型 Slice[T]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">FooMap</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">string</span><span class="p">]</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Slice</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">FooMap</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Slice</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span> <span class="p">|</span> <span class="nx">Slice</span><span class="p">[</span><span class="kt">string</span><span class="p">]]</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">T</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="类型约束的两种写法">类型约束的两种写法</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">FooStruct</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">string</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Data</span> <span class="p">[]</span><span class="nx">T</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">BarStruct</span><span class="p">[</span><span class="nx">T</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">|</span> <span class="p">[]</span><span class="kt">string</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Data</span> <span class="nx">T</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>匿名结构体不支持泛型</p>
<p>这使得在进行单元测试时，为泛型做单元测试变得很麻烦</p>
</blockquote>
<h2 id="泛型-receiver">泛型 Receiver</h2>
<p>Go 泛型支持给泛型类型添加方法，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">string</span><span class="p">]</span> <span class="p">[]</span><span class="nx">T</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Sum</span><span class="p">()</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">sum</span> <span class="nx">T</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">value</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">sum</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>实例化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s</span> <span class="nx">Slice</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Sum</span><span class="p">())</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过泛型 Receiver，泛型的实用性得到了很大的扩展，我们可以很简单的创建通用的数据结构，在这之前我们如果想要实现通用的数据结构（堆、栈、链表、队列）只能使用两种方法</p>
<ul>
<li>每种类型挨个实现（啰嗦、麻烦）</li>
<li>接口 + 反射（麻烦、难理解）</li>
</ul>
<h3 id="基于泛型的队列">基于泛型的队列</h3>
<p>我们不必像之前那样为每个类型都实现一个队列，直接使用泛型 Receiver 便可简单的实现，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Queue</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">elements</span> <span class="p">[]</span><span class="nx">T</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 将数据加入队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">Queue</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">value</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">q</span><span class="p">.</span><span class="nx">elements</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">elements</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 将数据从队列取出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">Queue</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Pop</span><span class="p">()</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">value</span> <span class="nx">T</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">elements</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">value</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">value</span> <span class="p">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">q</span><span class="p">.</span><span class="nx">elements</span> <span class="p">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">elements</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">value</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">elements</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 队列大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">Queue</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Size</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">elements</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">q1</span> <span class="nx">Queue</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">q1</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">q1</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">q1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">q1</span> <span class="nx">Queue</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">q2</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="s">&#34;A&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">q2</span><span class="p">.</span><span class="nf">Pur</span><span class="p">(</span><span class="s">&#34;B&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">q2</span><span class="p">.</span><span class="nf">Pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nx">q2</span><span class="p">.</span><span class="nf">Pop</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>泛型不能像空接口一样进行类型的动态判断，但是我们可以使用反射进行类型的动态判断<del>这很恶心🤢</del></p>
</blockquote>
<h2 id="泛型函数">泛型函数</h2>
<p>泛型函数的写法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Add</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">float64</span><span class="p">](</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它和普通函数的区别就是在函数名后带了类型形参，泛型函数可以显式的传入类型实参也可以不传入类型实参，编译器可以自动推断；一般情况下编译器会告诉你传入类型实参是没必要的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">value</span> <span class="p">=</span> <span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// 编译器推断出类型实参为 int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">value</span> <span class="p">=</span> <span class="nx">Add</span><span class="p">[</span><span class="kt">int</span><span class="p">](</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// 显式的传入类型实参 int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">value</span> <span class="p">=</span> <span class="nx">Add</span><span class="p">[</span><span class="kt">float32</span><span class="p">](</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="c1">// 显式的传入类型实参 float32
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>匿名函数</strong>不支持泛型，但是匿名函数可以使用别处定义好的类型实参，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">FooFunc</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">float32</span> <span class="p">|</span> <span class="kt">float64</span><span class="p">](</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fn2</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">i</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="nx">j</span> <span class="o">*</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">fn2</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="泛型方法">泛型方法？</h3>
<p>函数都支持泛型了，而且含有泛型 Receiver，那方法就一定支持泛型吧？很遗憾，目前Go官方并不支持泛型方法，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">A</span> <span class="kd">struct</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// error, 不支持泛型方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span><span class="p">(</span><span class="nx">receiver</span> <span class="nx">A</span><span class="p">)</span> <span class="nx">Add</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">float32</span> <span class="p">|</span> <span class="kt">float64</span><span class="p">](</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是因为 receiver 支持泛型，所以可以曲线救国一下，通过 receiver 使用类型形参</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">A</span> <span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">float32</span> <span class="p">|</span> <span class="kt">float64</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">receiver</span> <span class="nx">A</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">a</span> <span class="nx">A</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">a</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">b</span> <span class="nx">A</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="小结">小结</h2>
<p>Go 的泛型目前可以使用在如下三个地方：</p>
<ul>
<li>泛型类型 &ndash; 类型定义中带类型形参的类型</li>
<li>泛型 Receiver &ndash; 泛型类型的 Receiver</li>
<li>泛型函数 &ndash; 带类型形参的函数</li>
</ul>
<h2 id="变复杂的接口">变复杂的接口</h2>
<p>有时候使用泛型进行编程的时候，可能会书写一个很长长长的类型约束</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span> <span class="p">|</span> <span class="kt">int8</span><span class="p">|</span> <span class="kt">int16</span> <span class="p">|</span> <span class="kt">int32</span> <span class="p">|</span> <span class="kt">int64</span> <span class="p">|</span> <span class="kt">uint</span> <span class="p">|</span> <span class="kt">uint8</span> <span class="p">|</span> <span class="kt">uint16</span><span class="p">|</span> <span class="kt">uint32</span> <span class="p">|</span> <span class="kt">uint64</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使得可读性大大的下降，这可是无法忍受的。而 Go 支持将这些类型进行抽象，将其抽象为一个接口</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">IntUint</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="p">|</span> <span class="kt">int8</span> <span class="p">|</span> <span class="kt">int16</span> <span class="p">|</span> <span class="kt">int32</span> <span class="p">|</span> <span class="kt">int64</span> <span class="p">|</span> <span class="kt">uint</span> <span class="p">|</span> <span class="kt">uint8</span> <span class="p">|</span> <span class="kt">uint16</span> <span class="p">|</span> <span class="kt">uint32</span> <span class="p">|</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">T</span> <span class="nx">IntUint</span><span class="p">]</span> <span class="p">[]</span><span class="nx">T</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码吧类型约束单独拿出来，写入了接口类型 IntUint中，但是可维护性还是有点低，这是我们可以将接口和接口、接口和普同类型之间通过 <code>|</code> 进行组合，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Int</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">|</span> <span class="kt">int8</span> <span class="p">|</span> <span class="kt">int16</span> <span class="p">|</span> <span class="kt">int32</span> <span class="p">|</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Uint</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint</span> <span class="p">|</span> <span class="kt">uint8</span> <span class="p">|</span> <span class="kt">uint16</span> <span class="p">|</span> <span class="kt">uint32</span> <span class="p">|</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Int</span> <span class="p">|</span> <span class="nx">Uint</span><span class="p">]</span> <span class="p">[]</span><span class="nx">T</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在接口中也能直接组合其他接口，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SliceElement</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Int</span> <span class="p">|</span> <span class="nx">Uint</span> <span class="p">|</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">T</span> <span class="nx">SliceElement</span><span class="p">]</span> <span class="p">[]</span><span class="nx">T</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="指定底层类型-">指定底层类型： ~</h3>
<p>上面定义的 <code>Slice[T]</code> 虽然可以增加可维护性，但是有一个问题，就是它不能使用 NewType 来作为类型实参</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s1</span> <span class="nx">Slice</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span> <span class="c1">// right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NewInt</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s2</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">NewInt</span><span class="p">]</span> <span class="c1">// error, NewInt 的底层类型是 int 但是他不是 int 类型，不符合 Slice[T] 的类型约束
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这种问题该如何解决呢，贴心的官方给了我们一个新的符号 <code>~</code>，在类型约束中使用类型 <code>~int</code>这种写法，就代表任何底层类型为 int 类型的 NewType 都可以作为 Slice[T] 的类型实参，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Int</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">～</span><span class="kt">int</span> <span class="p">|</span> <span class="err">～</span><span class="kt">int8</span> <span class="p">|</span> <span class="err">～</span><span class="kt">int16</span> <span class="p">|</span> <span class="err">～</span><span class="kt">int32</span> <span class="p">|</span> <span class="err">～</span><span class="kt">int64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Uint</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">～</span><span class="kt">uint</span> <span class="p">|</span> <span class="err">～</span><span class="kt">uint8</span> <span class="p">|</span> <span class="err">～</span><span class="kt">uint16</span> <span class="p">|</span> <span class="err">～</span><span class="kt">uint32</span> <span class="p">|</span> <span class="err">～</span><span class="kt">uint64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Int</span> <span class="p">|</span> <span class="nx">Uint</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">FooInt</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s1</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">FooInt</span><span class="p">]</span> <span class="c1">// right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">BarInt</span> <span class="nx">FooInt</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s2</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">BarInt</span><span class="p">]</span> <span class="c1">// right
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>限制</strong>：使用 <code>~</code> 有一定的限制</p>
<ul>
<li><code>~</code> 后面不能为接口</li>
<li><code>~</code> 后面的类型必须为基本类型，不能为 NewType</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NewInt</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Int</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="p">[]</span><span class="kt">byte</span> <span class="c1">// right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">~</span><span class="nx">NewInt</span> <span class="c1">// error，~ 后类型必须为接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">~</span><span class="kt">error</span> <span class="c1">// error，~ 后的类型不能为接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="从方法集method-type到类型集type-set">从方法集（Method Type）到类型集（Type Set）</h3>
<p>上面的写法在1.18版本之前是没有的，因为在1.18之前官方对<code>接口（interface）</code>的定义为：接口是一个方法集（method set）</p>
<blockquote>
<p>An interface type specifies a <strong>method set</strong> called it interface</p>
</blockquote>
<p>就如同下面这段代码一样，<code>ReadWrite</code>接口定义了一个接口（方法集），这个集合包含了<code>Read()</code>和<code>Write()</code>两个方法。所有同时实现了这两种方法的类型就会被视为实现了这一接口（鸭子型别）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ReadWrite</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是如果换个角度来重新思考这个接口的话，会发现接口的定义实际上还能理解为：</p>
<blockquote>
<p>可以把<code>ReadWrite</code> 接口看成代表了一个类型的集合，所有实现了<code>Read()</code> 和 <code>Write()</code> 这两个方法的类型都在接口代表的类型集合中</p>
</blockquote>
<p>换个角度后，接口的定义就从<strong>方法集</strong>变为了<strong>类型集</strong>。而 Go 1.18 也将接口的定义更改为了：接口是一个类型集合（type set）</p>
<blockquote>
<p>An interface type defines a <strong>type set</strong></p>
</blockquote>
<h3 id="接口定义的变化">接口定义的变化</h3>
<p>从 Go 1.18 开始，当满足如下条件时，我们便可以说<strong>类型 T 实现了接口 I（type T implements interface I）</strong></p>
<ul>
<li>T 不是接口时：类型 T 是接口 I 代表的类型集中的一个成员（T is an element of the type set of I）</li>
<li>T 是接口时：T 接口代表的类型集是 I 代表的类型集的子集（Type set of T is subset of the type of I）</li>
</ul>
<h3 id="类型的并集">类型的并集</h3>
<p>之前一直是用的 <code>|</code> 符号就是求类型的并集（union）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">IntUint</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">|</span> <span class="kt">int8</span><span class="p">|</span> <span class="kt">int16</span> <span class="p">|</span> <span class="kt">int32</span> <span class="p">|</span> <span class="kt">int64</span> <span class="p">|</span> <span class="kt">uint</span> <span class="p">|</span> <span class="kt">uint8</span> <span class="p">|</span> <span class="kt">uint16</span><span class="p">|</span> <span class="kt">uint32</span> <span class="p">|</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="类型的交集">类型的交集</h3>
<p>接口（类型集）可以写多行，当为多行时，那么会取他们的交集</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">AllInt</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="kt">int</span> <span class="p">|</span> <span class="kt">int8</span><span class="p">|</span> <span class="kt">int16</span> <span class="p">|</span> <span class="kt">int32</span> <span class="p">|</span> <span class="kt">int64</span> <span class="p">|</span> <span class="kt">uint</span> <span class="p">|</span> <span class="kt">uint8</span> <span class="p">|</span> <span class="kt">uint16</span><span class="p">|</span> <span class="kt">uint32</span> <span class="p">|</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Uint</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">uint</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint16</span><span class="p">|</span> <span class="err">~</span><span class="kt">uint32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">A</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">AllInt</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Uint</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">B</span> <span class="kd">interface</span> <span class="p">{</span> <span class="c1">// 接口 B 即为 int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">AllInt</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>接口 A 代表的就是 <code>AllInt</code> 和 <code>Uint</code> 的交集，即 <code>uint | uint8 | uint16 | uint32 | uint64</code></p>
</li>
<li>
<p>接口 B 代表的就是 <code>AllInt</code> 和 <code>~int</code> 的交集，即 <code>int</code></p>
</li>
</ul>
<p>也可以进行一些放屁的写法，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">C</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接口<code>C</code> 代表的就是 <code>int</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">D</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float32</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接口 <code>D</code> 代表的就是一个空集，不同于空接口 <code>any</code>，它是无法传递类型实参的</p>
<h3 id="空接口和-any">空接口和 <code>any</code></h3>
<p>在 1.18 之后，空接口 <code>interface{}</code> 的定义为：</p>
<blockquote>
<p>空接口代表了所有类型的集合</p>
</blockquote>
<p>所以对于 1.18 后的空接口应理解为：</p>
<ul>
<li>虽然空接口没有写入任何类型，即没有类型约束，但是它代表了所有类型的集合，而非空集</li>
<li>类型约束中指定了空接口的意思是指定了一个包含所有类型的类型集，并不是类型约束限定了只能使用<strong>空接口</strong>来做类型</li>
</ul>
<p>因为空接口包含了所有的类型，所有 1.18 提供了一个新关键字 <code>any</code> ，它是 <code>interface{}</code> 的封装，能使代码更简单易懂</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="p">[]</span><span class="nx">T</span> <span class="c1">// 等价于 type Slice[T interface{}] []T
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果想把  1.18 版本之前的项目迁移到 1.18 中，可以使用如下命令（这是可选的）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gofmt -w -r <span class="s1">&#39;interface{} -&gt; any&#39;</span> ./...
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Go 语言项目中就有人曾提出过将所有的 interface{} 替换为 any 的 issue，但是因为影响过大且无法确定会发生什么奇奇怪怪的 🐛，理所当然的被驳回了。我觉得有一部分是理由是为了兼容性</p>
</blockquote>
<h3 id="可比较comparable和可排序ordered">可比较（Comparable）和可排序（Ordered）</h3>
<p>在写泛型的时候我们需要在类型约束中限制只能接受能 != 和 == 对比的类型，类似于 Rust 中的 <code>PartialEq Eq</code>trait，如 map：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// error，因为 map 中键的类型必须是可比较的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">NewMap</span><span class="p">[</span><span class="nx">K</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">V</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">map</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span><span class="nx">V</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这时贴心的官方给你内置了一个接口，叫做 <code>comparable</code>，它代表了所有的可比较类型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NewMap</span><span class="p">[</span><span class="nx">k</span> <span class="nx">comparable</span><span class="p">,</span> <span class="nx">V</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">map</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span><span class="nx">V</span> <span class="c1">// right
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是这里的可比较指的是可以执行 <code>!=</code> 和 <code>==</code> 操作的类型，并不确保这个类型可以执行 <code>&gt; &lt; &gt;= &lt;=</code>，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">FooStruct</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">a</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">FooStruct</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span> <span class="c1">// right，结构体可以使用 == 和 != 进行比较
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span> <span class="o">!=</span> <span class="nx">b</span> <span class="c1">// right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="c1">// error，结构体不支持比较大小
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果想比较大小，实现类似于 Rust 中的 <code>PartialOrd Ord</code> trait，官方并没有提供关键字，我们只能自己来实现。</p>
<p>比如我们可以参考官方的<code>golang.org/x/exp/constraints</code>如何定义</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Ordered 代表所有可以进行比较的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Ordered</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Integer</span> <span class="p">|</span> <span class="nx">Float</span> <span class="p">|</span> <span class="err">~</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Integer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Signed</span> <span class="p">|</span> <span class="nx">Unsigned</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Singed</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int16</span><span class="p">|</span> <span class="err">~</span><span class="kt">int32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Unsigned</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">uint</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint16</span><span class="p">|</span> <span class="err">~</span><span class="kt">uint32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Float</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float32</span> <span class="p">|</span> <span class="kt">float64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="接口的两种类型">接口的两种类型</h3>
<p>如下的例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">string</span> <span class="p">|</span> <span class="err">~</span><span class="p">[]</span><span class="kt">rune</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该如何理解这个例子？用类型集的概念就能轻松的理解这个接口的意思</p>
<blockquote>
<p>接口类型 ReadWriter 代表了一个类型集合，所有以 string 或 []rune 为底层类型，并实现了 Read() 和 Write() 这两个方法的类型都在 ReadWriter 代表的类型集中</p>
</blockquote>
<p>下面的例子中，<code>StringReadwriter</code>存在于<code>ReadWriter</code>代表的类型集中，<code>BytesReadWriter</code>并不属于<code>ReadWriter</code>代表的类型集合，因为它的底层类型为<code>[]byte</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">StringReadWriter</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">StringReadWriter</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">StringReadWriter</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">BytesReadWriter</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="nx">BytesReadWriter</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="nx">BytesReadWriter</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>停！！！这接口变得太复杂了吧，我定义一个 ReadWriter类型的接口变量，然后接口变量赋值的时候不仅要考虑到方法的实现，还有考虑底层类型，这也太🌿了吧。这时贴心的官方为了保持 Go 的兼容性，1.18 之后将接口分为两种类型：</p>
<ul>
<li><strong>基本接口（Basic interface）</strong></li>
<li><strong>一般接口（General interface）</strong></li>
</ul>
<h4 id="基本接口">基本接口</h4>
<p>接口的定义只有方法的话，那么这种接口被称为<strong>基本接口（Basic interface）</strong>。这种接口就是 1.18 之前的接口，用法也和之前一致。基本接口一般用于如下几个地方：</p>
<ul>
<li>
<p>最常用的，，定义接口变量赋值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NewError</span> <span class="kd">interface</span> <span class="p">{</span> <span class="c1">// 基本接口，只有方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">err</span> <span class="nx">NewError</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;new error&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>基本接口也代表了一个类型集，所有也可以用在类型约束中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// io.Reader 和 io.Writer 都是基本接口，也可用于类型约束中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">NewSlice</span><span class="p">[</span><span class="nx">T</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span> <span class="p">|</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">]</span> <span class="p">[]</span><span class="nx">Slice</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="一般接口">一般接口</h4>
<p>如果接口中不仅只有方法，还有类型的话或者只有类型，这种接口一般被称为<strong>一般接口（General interface）</strong>，如下都是一般接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Uint</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">uint8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint16</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint64</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">string</span> <span class="p">|</span> <span class="err">~</span><span class="p">[]</span><span class="kt">rune</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>一般接口类型不能用来定义变量，只能用于泛型的类型约束中</strong>，所以如下用法是错误的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Uint</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">uint8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint16</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint64</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">uintInf</span> <span class="nx">Uint</span> <span class="c1">// error，Uint是接口，只能用于类型约束，不得用于变量定义
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这一限制保证了一般接口的使用被限定在了泛型中，不会影响到 1.18 之前的代码（兼容性），同时也减少了书写时的心智负担</p>
<h3 id="泛型接口">泛型接口</h3>
<p>所有类型的定义都可以使用类型形参，所以接口定义自然也可以使用类型形参</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">DataProcessor</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Process</span><span class="p">(</span><span class="nx">oriData</span> <span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">newData</span> <span class="nx">T</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Save</span><span class="p">(</span><span class="nx">data</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">DataProcessor2</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kd">struct</span><span class="p">{</span> <span class="nx">Data</span> <span class="nx">any</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">Process</span><span class="p">(</span><span class="nx">data</span> <span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">newData</span> <span class="nx">T</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Save</span><span class="p">(</span><span class="nx">data</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为引入了类型形参，这两个接口都是泛型接口，<strong>而泛型类型要使用的话必须传入类型实参实例化才有意义</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">DataProcessor</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 实例化后的接口定义相当于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">DataProcessor</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Process</span><span class="p">(</span><span class="nx">oriData</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">newData</span> <span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Save</span><span class="p">(</span><span class="nx">data</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>DataProcessor[string]</code>只有方法，所以它是就是一个<strong>基本接口</strong>，这个接口包含了两个能处理string类型的方法。如下实现了这两个能处理string类型的方法就算实现了这个接口</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">CSVProcessor</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">CSVProcessor</span><span class="p">)</span> <span class="nf">Process</span><span class="p">(</span><span class="nx">oriData</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">newData</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;I get data %v&#34;</span><span class="p">,</span> <span class="nx">oriData</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="s">&#34;I am a CSV&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">CSVProcessor</span><span class="p">)</span> <span class="nf">Save</span><span class="p">(</span><span class="nx">data</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">processor</span> <span class="nx">DataProcessor</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span> <span class="p">=</span> <span class="nx">CSVProcessor</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">processor</span><span class="p">.</span><span class="nf">Process</span><span class="p">(</span><span class="s">&#34;name,age\nbob,12\njack,30&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">_</span> <span class="p">=</span> <span class="nx">processor</span><span class="p">.</span><span class="nf">Save</span><span class="p">(</span><span class="s">&#34;name,age\nbob,12\njack,30&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">processor</span> <span class="nx">DataProcessor</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span> <span class="p">=</span> <span class="nx">CSVProcessor</span><span class="p">{}</span> <span class="c1">// error，CSVProcessor没有实现接口 DataProcessor[int]
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>再用同样的方法实例化一下 DataProcessor2[T]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">DataProcessor2</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">DataProcessor2</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kd">struct</span><span class="p">{</span> <span class="nx">Data</span> <span class="nx">any</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">Process</span><span class="p">(</span><span class="nx">data</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">newData</span> <span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Save</span><span class="p">(</span><span class="nx">data</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>DataProcessor2[string]</code>因为带有类型并集，所以它是<strong>一般接口</strong>，所以实例化后代表的意思为：</p>
<ul>
<li>只有实现了 <code>Process( data string) (newData string)</code> 和 <code>Save(data string) error</code> 这两个方法，并且以 <code>int</code> 或 <code>struct { Data any }</code>为底层类型的类型才算实现了这个接口</li>
<li><strong>一般接口</strong>不能用于定义变量只能用于类型约束，所以接口<code>DataProcessor2[string]</code>只是定义了一个用于类型约束的类型集</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// XMLProcessor 实现了两个方法，但是它的底层类型是 []byte，所以它并没有实现接口 DataProcessor2[string]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">XMLProcessor</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">XMLProcessor</span><span class="p">)</span> <span class="nf">Process</span><span class="p">(</span><span class="nx">oriData</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">newData</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="s">&#34;I am XML&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">XMLProcessor</span><span class="p">)</span> <span class="nf">Save</span><span class="p">(</span><span class="nx">data</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// JsonProcessor 实现了两个方法，底层类型也是 struct { Data any }，所以实现了 DataProcessor2[string]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">JsonProcessor</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Data</span> <span class="nx">any</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="nx">JsonProcessor</span><span class="p">)</span> <span class="nf">Process</span><span class="p">(</span><span class="nx">oriData</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">newData</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="s">&#34;I am Json&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="nx">JsonProcessor</span><span class="p">)</span> <span class="nf">Save</span><span class="p">(</span><span class="nx">data</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// error，一般接口不能用于创建变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">processor</span> <span class="nx">DataProcessor2</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// right，实例化后的DataProcessor2可以用于泛型的类型约束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">stringProcessor</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">DataProcessor2</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">PrintString</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// error，带方法的一般接口不能作为类型并集的成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">StringProcessor</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">DataProcessor2</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span> <span class="p">|</span> <span class="nx">DataProcessor2</span><span class="p">[[]</span><span class="kt">byte</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">PrintString</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="接口定义的种种限制">接口定义的种种限制</h3>
<p>在 1.18 引入泛型后，定义类型集（接口）的时候增加了非常多的十分琐碎的限制规则，有一些规则在之前已经写过了，下面还有一些规则统一的罗列一下</p>
<ol>
<li>
<p>用 <code>|</code> 连接多个类型时，类型直接不能有相交的部分（即类型直接必须为无交集）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NewInt</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// error，NewInt 和 ~int 有相交的部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">_</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="nx">NewInt</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是相交的类型是接口的话，则不受这一限制</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NewInt</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">_</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nx">NewInt</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">_</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">interface</span><span class="p">{</span> <span class="err">~</span><span class="kt">int</span> <span class="p">}</span> <span class="p">|</span> <span class="nx">NewInt</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">_</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">interface</span><span class="p">{</span> <span class="err">~</span><span class="kt">int</span> <span class="p">}</span> <span class="p">|</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nx">Newint</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>类型并集中不能有类型形参</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NewInf</span><span class="p">[</span><span class="nx">T</span> <span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kt">string</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">float32</span> <span class="p">|</span> <span class="nx">T</span> <span class="c1">// error，T 是类型形参
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NewInf</span><span class="p">[</span><span class="nx">T</span> <span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kt">string</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">T</span> <span class="c1">// error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>接口不能直接或间接的并入自身</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Bad</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Bad</span> <span class="c1">// error，接口不能并入自身
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Bad2</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Bad1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Bad1</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Bad2</span> <span class="c1">// error，接口 Bad1 通过 Bad2 间接并入了自身
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Bad3</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kt">string</span> <span class="p">|</span> <span class="nx">Bad3</span> <span class="c1">// error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>接口成员个数大于一的时候不能直接或间接并入 <code>comparable</code> 接口</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Ok</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">comparable</span> <span class="c1">// right，只有一个类型约束时可以使用 comparable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Bad1</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">[]</span><span class="kt">int</span> <span class="p">|</span> <span class="nx">comparabel</span> <span class="c1">//error，直接并入 comparabel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">CmpInf</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">comparable</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Bad2</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">chan</span> <span class="kt">int</span> <span class="p">|</span> <span class="nx">CmpInf</span> <span class="c1">// error，间接并入 comparable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Bad3</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">chan</span>  <span class="kt">int</span> <span class="p">|</span> <span class="kd">interface</span><span class="p">{</span><span class="nx">CmpInt</span><span class="p">}</span> <span class="c1">// error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>带方法的接口（无论是基本接口还是一般接口），都不能写入接口的并集中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">_</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kt">string</span> <span class="p">|</span> <span class="kt">error</span> <span class="c1">// error，error 是带方法的接口(基本接口)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">DataProcessor</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">string</span> <span class="p">|</span> <span class="err">~</span><span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">Process</span><span class="p">(</span><span class="nx">data</span> <span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">newData</span> <span class="nx">T</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Save</span><span class="p">(</span><span class="nx">data</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// error，实例化后的 DataProcessor[string] 是一般接口，不能写入类型并集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">_</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kt">string</span> <span class="p">|</span> <span class="nx">Dataprocessor</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="总结">总结</h2>
<p>以上就是 Go 语言官方在 1.18 引入的新特性泛型。</p>
<blockquote>
<p>泛型并不取代1.18之前利用接口+反射的方式实现的动态类型，泛型的适用场景是：当你需要对不同类型书写相同逻辑时，适用泛型是简化代码的最好办法（比如写一些数据结构，堆、栈、链表等）</p>
</blockquote>
<h2 id="参考">参考</h2>
<ul>
<li>[1] <a href="https://segmentfault.com/a/1190000041634906">Go 1.18 泛型全面讲解：一篇讲清泛型的全部</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">MysticalDevil</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2023-01-23
        
    </span>
  </p>
  
  
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/images/wechat-reward-qrcode.png">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/images/alipay-reward-qrcode.png">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          <a href="/tags/generic/">Generic</a>
          </div>
      <nav class="post-nav">
        
        
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="MysticalDevil/mysticaldevil.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="jinpeng7981@outlook.com" class="iconfont icon-email" title="email"></a>
      <a href="https://stackoverflow.com/users/15772868/mystical-c" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://github.com/MysticalDevil" class="iconfont icon-github" title="github"></a>
      <a href="https://space.bilibili.com/10997055?spm_id_from=333.1007.0.0" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>MysticalDevil</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
